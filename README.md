***一个简单的 Key-value 的存储引擎***

- [ ] 使用 `SkipList` 在内存中组织数据
- [ ] `WAL` 保证数据不会丢失
- [ ] `SSTable` 架构组织数据， 持久化到磁盘中


### table_builder 插入数据后磁盘内容

```sh
00000000  00 07 05 63 6f 6e 66 75  73 65 76 61 6c 75 65 03  |...confusevalue.|
00000010  04 05 74 65 6e 64 76 61  6c 75 65 02 02 05 70 65  |..tendvalue...pe|
00000020  76 61 6c 75 65 03 01 05  79 76 61 6c 75 65 00 04  |value...yvalue..|
00000030  05 63 6f 72 6e 76 61 6c  75 65 00 00 00 00 2e 00  |.cornvalue......|
00000040  00 00 02 00 00 00 01 e8  e5 ed 99 00 87 93 42 0b  |..............B.|
00000050  07 43 23 06 00 00 00 00  09 00 00 00 0b 00 47 af  |.C#...........G.|
00000060  7e f1 00 12 02 66 69 6c  74 65 72 2e 42 6c 6f 6f  |~....filter.Bloo|
00000070  6d 46 69 6c 74 65 72 4b  12 00 00 00 00 01 00 00  |mFilterK........|
00000080  00 01 4e 6a 85 24 00 01  02 64 00 46 00 00 00 00  |..Nj.$...d.F....|
00000090  01 00 00 00 01 8f c6 2f  15 62 1f 86 01 0e 00 00  |......./.b......|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000c0  00 57 fb 80 8b 24 75 47  db                       |.W...$uG.|
000000c9
```


### 测试文件

> - ***test_filter_block***: 测试 ***布隆过滤器*** 是否成功 【内存中】
> - ***testTableBuilder***: 测试 **写入Table**到磁盘中，上面是 `hexdump` 数据格式
> - ***testTableReader:*** 测试 **读取上面写入的table**，然后迭代器遍历数据
> - ***testblock***: 测试 **block的生成、迭代遍历等** 【内存中】
> - ***testSkipList***: 测试 跳表是否成功 【内存中】


### MemTableIterator 的设计

> - ***MemTable*** 内部使用 **skiplist** 进行维护数据
> - ***MemtableIterator*** 作为 **memtable** 的友元类出现，为了访问 **skiplist** 

怎么创建 ***memtableiterator*** 呢？ **MemTable** 中有一个成员函数 `Iterator* NewIterator()` 用来创建本 **memtable** 的迭代器，传入 ***table_*** 生成迭代器类



### 🐛:

1. 不要在 头文件中 定义函数，可以声明但是不要在头文件中定义非类的成员函数，在.cc文件中定义

2. IteratorWrapper 构造函数传入iter的时候忘记调用 Set(), 导致上层的 iter 一直是空的

   
